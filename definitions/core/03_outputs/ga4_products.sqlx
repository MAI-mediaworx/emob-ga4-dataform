config {
  type: "incremental",
  uniqueKey: ['session_id', "item_id"],
  description: "Intermediate incremental sessions table with modeling helpers implemented. 1 row per unique session_id. Contains only valid sessions.",
  database: dataform.projectConfig.vars.OUTPUT_PROJECT,
  schema: dataform.projectConfig.vars.TRANSFORMATIONS_DATASET,
  tags:[dataform.projectConfig.vars.GA4_DATASET,"sessions","dev"],
  bigquery: {
    partitionBy: "event_date",
    clusterBy: [ "session_id" ],
    // labels: require("includes/core/helpers.js").helpers.storageLabels()
  },
}

js {
    const { helpers } = require("includes/core/helpers");
    const config = helpers.getConfig();
}

/* incrementality */
pre_operations {
  declare date_checkpoint DATE;
--   set @@query_label = "${helpers.executionLabels()}";
  set date_checkpoint = (
    ${when(incremental(),
      `select
        coalesce(max(session_date)+1, date('${config.GA4_START_DATE}'))
      from ${self()}
      where is_final = true`,
    `select date('${config.GA4_START_DATE}')`)}   /* the default, when it's not incremental */
  );
    -- delete some older data, since this may be updated later by GA4
  ${
    when(incremental(),
      `delete from ${self()} where session_date >= date_checkpoint`
      )
  }
}

-- simple sessions: referrers as is, no Last Non Direct - 1 source per session (the first no null)

with events as (
  select
    '${dataform.projectConfig.vars.GA4_DATASET}' as property_id,
    min(event_date) as event_date,
    session_id,
    event_id,
    stream_id,
    user_pseudo_id, 
    max(is_active_user) is_active_user,
    ${helpers.generateArrayAggSQL('user_id',false, false)}, -- to account for potentially multiple

    -- min(table_suffix) as table_suffix,
    count(distinct table_suffix) > 1 as is_multiday_session,  -- for later AZ

    -- first
    ${helpers.generateArrayAggSQL('device')},
    ${helpers.generateArrayAggSQL('geo')},
    ${helpers.generateArrayAggSQL('app_info')},
    ${helpers.generateArrayAggSQL('platform')},

    --  traffic info
    -- ${helpers.generateArrayAggSQL('session_traffic_source_last_click', 'session_traffic_source_last_click')} ,
    ${helpers.generateArrayAggSQL('session_traffic_source_last_click.cross_channel_campaign', 'cross_channel_campaign')} ,

    -- do we need user info in ecomm table? AZ
        -- min(event_params.ga_session_number) as ga_session_number, -- could be NULL when hit comes from MP
        -- CASE 
        --   WHEN min(event_params.ga_session_number) = 1 THEN 'new user'
        --   WHEN min(event_params.ga_session_number) > 1 THEN 'returning user'
        --   ELSE NULL
        -- END AS user_type,
        -- do we need sesssion info in ecomm table? AZ
        -- logical_or(event_params.session_engaged = 1) as is_engaged_session,
        -- min(timestamp_micros(event_timestamp)) as session_start_timestamp_utc,
        -- max(timestamp_micros(event_timestamp)) as session_end_timestamp_utc,
        -- sum(cast(event_params.engagement_time_msec as int64)) as engagement_time_msec,

        count(event_name) events,
        countif(event_name="page_view") pageviews,
        sum(if(event_name="purchase", ecommerce.purchase_revenue, 0)) purchase_revenue,
        sum(if(event_name="purchase", ecommerce.total_item_quantity,0)) total_item_quantity,
        sum(if(event_name="purchase", ecommerce.unique_items,0)) unique_items, 
        count(distinct if(event_name="purchase", ecommerce.transaction_id, NULL)) transactions,

        -- and key events as metrics - also not needed AZ
        -- ${when(
        --   config.KEY_EVENTS_ARRAY.length > 0,
        --     `${helpers.getSqlSelectEventsAsMetrics(config.KEY_EVENTS_ARRAY)}  `
        --   )} ,

       max(is_final) as is_final --return true if session started on an is_final day


  from   ${ref("base_ga4_items")}
  where event_date >= date_checkpoint -1 -- grab 1 extra day, to include sessions starting earlier

  -- only hits with user_pseudo_id and session_id
  and user_pseudo_id is not null
  and session_id is not null
  group by
    property_id,
    session_id,
    stream_id,
    user_pseudo_id
    -- this should not lead to duplicates. If it does, we'll get rid of those in ga4_sessions anyway
),


-- create time struct + session_source struct with first and last traffic_source of the session
add_meta_info as (
  select
    * except (
        -- source,
        -- source_category,
        session_start_timestamp_utc,
        session_end_timestamp_utc,
        engagement_time_msec
        -- first_traffic_source,
        -- last_traffic_source,
        -- first_click_ids,
        -- last_click_ids
        ),
    struct(
      session_start_timestamp_utc,
      session_end_timestamp_utc,
      engagement_time_msec,
      timestamp_diff(session_end_timestamp_utc, session_start_timestamp_utc, second) as session_duration_sec
    ) as time

    -- cross_channel_campaign.*
  from events
)

-- add_meta_info as (
--   select
--     * except (
--         source,
--         source_category,
--         session_start_timestamp_utc,
--         session_end_timestamp_utc,
--         engagement_time_msec,
--         first_traffic_source,
--         last_traffic_source,
--         first_click_ids,
--         last_click_ids
--         ),
--     struct(
--       session_start_timestamp_utc,
--       session_end_timestamp_utc,
--       engagement_time_msec,
--       timestamp_diff(session_end_timestamp_utc, session_start_timestamp_utc, second) as session_duration_s
--     ) as time,
--     (
--      select as struct
--       (
--         select as struct
--         first_traffic_source.*,
--         first_click_ids.*,
--         ${helpers.getDefaultChannelGroupingSQL(config,
--                                             'first_traffic_source.source',
--                                             'first_traffic_source.medium',
--                                             'first_traffic_source.campaign',
--                                             'join_first.source_category',
--                                             'first_traffic_source.term',
--                                             'first_traffic_source.content',
--                                             'first_traffic_source.campaign_id'
--                                             )} as default_channel_grouping,
--         ) first,
--       (
--         select as struct
--         last_traffic_source.*,
--         last_click_ids.*,
--         ${helpers.getDefaultChannelGroupingSQL(config,
--                                             'last_traffic_source.source',
--                                             'last_traffic_source.medium',
--                                             'last_traffic_source.campaign',
--                                             'join_last.source_category',
--                                             'last_traffic_source.term',
--                                             'last_traffic_source.content',
--                                             'last_traffic_source.campaign_id'
--                                             )} as default_channel_grouping
--       ) last
--     ) session_source,

--     cross_channel_campaign.*
--   from events
-- )

select
  *  --except(is_multiday_session)
from add_meta_info
where (
  session_date >= date_checkpoint -- new sessions
--   or is_multiday_session -- or older sessions from yesterday
)
-- could be some incremental duplicates, these will be discarded downstream